
#### **用过哪些设计模式？**

设计模式可以分为三大类：**创建型模式**、**结构型模式**、**行为型模式**。常用的包括以下几个：

##### **创建型模式**：
- **单例模式**：确保一个类只有一个实例，并提供全局访问点。  
  **应用**：线程池、日志管理器。
  
- **工厂方法模式**：定义一个接口，让子类决定实例化哪个类。  
  **应用**：使用抽象工厂创建对象，比如数据库连接池。

- **建造者模式**：将对象构建的复杂过程分解为多个步骤，然后逐步创建。  
  **应用**：复杂对象（如 JSON 解析器、报表生成器）。

##### **结构型模式**：
- **适配器模式**：将一个类的接口转换为客户期望的接口。  
  **应用**：适配旧代码，接口不一致时用到。

- **装饰器模式**：动态扩展对象功能而不改变其定义。  
  **应用**：添加日志功能、动态设置属性。

- **代理模式**：为其他对象提供一种代理以控制对它的访问。  
  **应用**：远程代理（RPC）、虚拟代理（延迟加载）。

##### **行为型模式**：
- **观察者模式**：定义一种依赖关系，当一个对象状态改变时通知其依赖对象。  
  **应用**：事件通知机制（如 GUI 编程、订阅发布系统）。

- **状态模式**：允许一个对象在其内部状态改变时改变行为。  
  **应用**：状态机（如订单状态处理、任务状态管理）。

- **策略模式**：定义一组算法，将每个算法封装起来，并使它们可以互换。  
  **应用**：支付策略（如微信支付、支付宝支付）。

##### **实际经验**：
- 在 **ROS** 项目中，使用了 **观察者模式** 来监听传感器状态变化。
- 在分布式系统中，用过 **单例模式** 管理日志模块。
- 在 UI 开发中，用过 **装饰器模式** 添加动态功能。

---

#### **C++11 和 C++17 分别有哪些新特性？**

##### **C++11 的新特性**：
1. **智能指针**：`std::shared_ptr`、`std::unique_ptr` 等，用于资源管理。
2. **右值引用与移动语义**：通过 `&&` 提升性能，避免不必要的拷贝。
3. **线程与并发**：标准库中引入 `std::thread`、`std::mutex`、`std::future`。
4. **Lambda 表达式**：轻量级函数对象，简化代码书写。
5. **自动类型推导**：`auto` 和 `decltype` 简化变量声明。
6. **范围 for 循环**：简化遍历容器操作。
7. **nullptr**：引入类型安全的空指针，取代传统 `NULL`。
8. **常量表达式**：`constexpr` 用于编译期计算。
9. **统一初始化**：大括号 `{}` 初始化方式，统一不同类型的初始化。
10. **变长模板**：`template<typename... Args>` 支持可变参数模板。

##### **C++17 的新特性**：
1. **结构化绑定**：简化解构赋值，如 `auto [x, y] = std::make_pair(1, 2);`。
2. **`std::optional`**：用于表示可能为空的值，避免大量的 `if` 判断。
3. **`std::variant`**：类似于联合体，表示多个可能的值类型。
4. **`std::any`**：可存储任意类型的值。
5. **`if constexpr`**：在编译期选择分支，增强了模板的灵活性。
6. **文件系统库**：`std::filesystem` 提供跨平台的文件和目录操作。
7. **平铺折叠表达式**：简化模板参数包操作。
8. **新标准属性**：如 `[[nodiscard]]` 提示返回值需要使用。
9. **`std::string_view`**：轻量级字符串视图，避免重复分配内存。
10. **内联变量**：允许 `constexpr` 或 `static` 成员变量的定义放在头文件中。

---

#### **Netty 的粘包和拆包**

##### **粘包与拆包的原因**：
- **粘包**：多条小数据在传输过程中被合并到一起，接收端一次收到多条完整消息。
- **拆包**：一条大数据在传输过程中被拆分为多部分，接收端一次收到不完整消息。

##### **产生原因**：
1. TCP 是基于流的协议，消息之间没有边界。
2. 数据发送速度快，缓冲区未满时会合并发送。
3. 数据过大，超过缓冲区大小。

##### **解决方案**：
1. **固定长度**：
   - 每条消息的长度固定，接收端按固定长度解析。
   - 缺点：浪费空间，不适用于长度不定的消息。

2. **分隔符**：
   - 消息以特定分隔符结尾（如 `\n` 或自定义字符）。
   - 使用 Netty 提供的 `DelimiterBasedFrameDecoder`。

3. **消息头指定长度**：
   - 消息头包含消息的总长度，接收端根据长度解析消息。
   - 使用 Netty 提供的 `LengthFieldBasedFrameDecoder`。

4. **应用层协议**：
   - 定义协议格式，比如 JSON 或 Protobuf，自定义序列化和反序列化。

##### **Netty 实现粘包/拆包处理**：
- 使用 `LengthFieldBasedFrameDecoder`：
```java
pipeline.addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, 0, 4));
pipeline.addLast(new LengthFieldPrepender(4));
```
- 使用分隔符：
```java
ByteBuf delimiter = Unpooled.copiedBuffer("\n".getBytes());
pipeline.addLast(new DelimiterBasedFrameDecoder(1024, delimiter));
```

---

#### **分布式事务**

##### **问题背景**：
在分布式系统中，多个服务间的操作需要保证一致性，例如订单服务和支付服务需要保持一致。

##### **常用解决方案**：
1. **二阶段提交（2PC）**：
   - **阶段 1（准备阶段）**：所有参与方准备好资源并锁定。
   - **阶段 2（提交阶段）**：协调者决定提交或回滚。
   - **优点**：保证强一致性。
   - **缺点**：性能开销大，容易出现单点问题。

2. **三阶段提交（3PC）**：
   - 在 2PC 基础上引入超时机制，减少锁定时间。
   - **优点**：更高的容错能力。
   - **缺点**：实现复杂。

3. **本地消息表**：
   - 使用本地事务先写入消息表，其他服务异步处理消息。
   - **优点**：避免长时间锁定，性能较好。
   - **缺点**：需要定时校对消息表。

4. **TCC（Try-Confirm-Cancel）**：
   - **Try**：尝试预留资源。
   - **Confirm**：真正执行。
   - **Cancel**：释放资源。
   - **优点**：灵活，适合业务操作复杂的场景。
   - **缺点**：实现复杂，业务侵入性强。

5. **最终一致性（基于消息队列）**：
   - 使用消息队列异步通知，确保最终达到一致性。
   - **优点**：高性能，适合弱一致性要求的场景。
   - **缺点**：不适用于实时性要求高的业务。

##### **应用场景**：
- **订单系统**：订单创建后需要异步扣减库存和生成发票。
- **支付系统**：支付完成后通知账户系统和积分系统。

##### **推荐实现**：
- 如果性能要求高，选择 **本地消息表** 或 **最终一致性**。
- 如果一致性要求高，选择 **TCC** 或 **2PC**。

---

希望这些回答能帮助你更好地准备面试！如果需要更详细的解答，可以随时问我！
