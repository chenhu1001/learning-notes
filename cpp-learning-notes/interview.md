### 1. **引用和指针的区别？**
   - **引用**：引用是一个变量的别名，必须在声明时初始化，并且无法更改指向的对象。引用不占用额外的内存，它是已存在对象的一个别名。
   - **指针**：指针是一个变量，它存储的是另一个变量的内存地址。指针可以修改指向不同的对象，并且它自己占用内存。

---

### 2. **从汇编层去解释一下引用**
   - 引用在底层汇编中是通过指针实现的，引用本身不会产生新的存储地址，它只是将变量的地址赋给汇编中的指针操作。
   - 引用的行为在汇编中通常表现为直接对变量内存地址的操作，而无需间接使用指针操作。

---

### 3. **C++中的指针参数传递和引用参数传递**
   - **指针参数传递**：传递的是指向对象的地址，函数可以通过指针改变对象的值。
   - **引用参数传递**：传递的是对象本身的别名，函数可以通过引用直接修改对象的值，且语法上更为简洁。

---

### 4. **形参与实参的区别？**
   - **形参**：在定义函数时声明的参数称为形式参数，它是占位符。
   - **实参**：在调用函数时传递给形参的具体值或对象，称为实际参数。

---

### 5. **static的用法和作用？**
   - **在函数中**：`static` 修饰的局部变量在函数结束后仍然保留其值。
   - **在类中**：`static` 修饰的成员变量或成员函数是类级别的，所有对象共享同一份静态成员。
   - **在全局作用域中**：`static` 修饰的函数或变量只能在定义它的文件中可见（文件范围的作用域）。

---

### 6. **静态变量什么时候初始化？**
   - **全局静态变量**：在程序开始时初始化。
   - **局部静态变量**：在第一次调用包含它的函数时初始化，且在后续函数调用时不再初始化。

---

### 7. **const?**
   - `const` 是一种常量限定符，用于指明变量的值不能被修改。可以用于变量、函数参数、返回值、成员函数等。

---

### 8. **const 成员函数的理解和应用？**
   - `const` 成员函数不能修改类的成员变量（除非该变量被声明为 `mutable`）。通常用于不改变对象状态的访问函数。

---

### 9. **指针和const的用法？**
   - **指向常量的指针**：`const int* ptr`，指针指向的值不能被修改，但指针本身可以指向不同的对象。
   - **常量指针**：`int* const ptr`，指针本身不能被修改，但指针指向的值可以修改。
   - **指向常量的常量指针**：`const int* const ptr`，指针本身和指向的值都不能修改。

---

### 10. **mutable**：
   - `mutable` 关键字允许即使在 `const` 成员函数中也能修改该成员变量。通常用于那些需要被改变，但不影响类逻辑的成员。

---

### 11. **extern 用法？**
   - `extern` 关键字用于声明变量或函数在其他文件中定义。它告诉编译器该变量或函数的定义在别处。

---

### 12. **int 转字符串的操作？**
   - 可以使用标准库函数 `strcat`, `strcpy`, `strncpy`, `memset`, `memcpy` 等处理字符串。
   - C++ 中可以使用 `std::to_string()` 函数将 `int` 转换为字符串。

---

### 13. **深拷贝与浅拷贝？**
   - **浅拷贝**：浅拷贝只是复制对象中的指针，而不会复制实际的数据。两个对象共享同一块内存，如果其中一个对象修改了数据，另一个对象的内容也会随之改变。浅拷贝使用默认的拷贝构造函数或赋值运算符。
   - **深拷贝**：深拷贝会复制对象中的指针及其指向的数据。即使对象共享同一类型的数据，深拷贝会为每个对象分配独立的内存，以避免一个对象的修改影响另一个对象。

---

### 14. **C++ 模板是什么，底层怎么实现的？**
   - **C++ 模板**：模板是一种通用编程工具，允许编写与类型无关的代码。分为**函数模板**和**类模板**，用于生成不同类型的函数或类的代码。
   - **底层实现**：编译器在编译时根据使用的具体类型实例化模板，生成对应类型的代码。这种机制被称为模板实例化。在模板实例化过程中，编译器会为每个被使用的类型生成一份模板代码。

---

### 15. **C 语言 struct 和 C++ struct 区别？**
   - 在 **C 语言** 中，`struct` 仅仅是一个数据结构，不能包含成员函数，默认所有成员是**公共的**。
   - 在 **C++** 中，`struct` 和 `class` 的功能基本相同，区别是 `struct` 默认成员和继承是 **public**，而 `class` 默认是 **private**。此外，C++ 中的 `struct` 允许包含成员函数、静态成员、构造函数等。

---

### 16. **虚函数可以声明为 inline 吗？**
   - 是的，虚函数可以声明为 `inline`，但是在实际运行时，虚函数的调用通常通过**虚函数表（vtable）**进行动态绑定，因此虚函数在大多数情况下不能真正内联化。编译器无法确定具体的虚函数版本，无法展开内联。

---

### 17. **类成员初始化方式？构造函数的执行顺序？为什么成员初始化列表会更快一些？**
   - **类成员初始化**：通常通过构造函数的初始化列表或在构造函数体内初始化。
   - **执行顺序**：构造函数的初始化顺序是根据成员变量在类中的声明顺序，而不是初始化列表中的顺序。
   - **成员初始化列表更快**：因为在进入构造函数体之前，成员已经被初始化。使用初始化列表时，可以直接对对象进行初始化，而在构造函数体中初始化，可能会先调用默认构造函数再进行赋值，增加了不必要的开销。

---

### 18. **成员列表初始化？**
   - **成员列表初始化**是通过构造函数的初始化列表对类成员进行直接初始化的一种方式：
     ```cpp
     class MyClass {
         int x;
         int y;
     public:
         MyClass(int a, int b) : x(a), y(b) {}
     };
     ```
     这样做效率更高，特别是对于常量成员、引用成员和没有默认构造函数的对象成员。

---

### 19. **构造函数为什么不能为虚函数？析构函数为什么要虚函数？**
   - **构造函数不能是虚函数**：构造函数在创建对象时调用，而虚函数依赖于对象的 `vtable`，在构造函数执行时 `vtable` 尚未构造完成，因此构造函数不能是虚函数。
   - **析构函数应为虚函数**：当一个指向派生类对象的基类指针被删除时，如果析构函数不是虚的，只有基类的析构函数会被调用，导致派生类资源无法正确释放。因此，析构函数应该是虚函数，以确保派生类的析构函数被正确调用。

---

### 20. **析构函数的作用，如何起作用？**
   - **析构函数**在对象销毁时自动调用，用于释放资源（如动态分配的内存、文件句柄等）。析构函数的作用是清理对象的状态，防止内存泄漏。析构函数没有返回值和参数，通常在对象生命周期结束时调用。

---

### 21. **构造函数和析构函数可以调用虚函数吗，为什么？**
   - **构造函数不能调用虚函数**：在构造函数中，虚函数机制尚未生效，编译器只会调用当前类中的版本，而不会调用派生类中的虚函数。
   - **析构函数调用虚函数**：如果析构函数是虚函数，当对象通过基类指针被删除时，派生类的析构函数会被调用，从而保证派生类的资源得到正确释放。

---

### 22. **构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？**
   - **构造函数执行顺序**：构造函数按从基类到派生类的顺序依次调用，首先初始化成员变量，然后执行构造函数体。
   - **析构函数执行顺序**：析构函数按从派生类到基类的顺序依次调用。
   - **构造函数的作用**：分配对象所需的内存，并初始化成员变量。
   - **拷贝构造函数**：拷贝构造函数负责复制对象，通常按值逐一复制成员变量。如果类中包含指针成员，可能需要进行深拷贝。

---

### 23. **虚析构函数的作用，父类的析构函数是否需要设置为虚函数？**
   - **虚析构函数**：确保通过基类指针删除派生类对象时，派生类的析构函数被正确调用。
   - **父类的析构函数需要设置为虚函数**：如果类被设计为多态基类，那么它的析构函数应为虚函数，以确保派生类对象的资源正确释放。

---

### 24. **类的构造析构函数可以抛出异常吗？**
   - **构造函数可以抛出异常**：如果在对象的构造过程中出现问题，可以抛出异常，以防止对象被创建。捕获到异常后，编译器会自动调用已经成功构造的成员或基类的析构函数，确保资源被正确释放。
   - **析构函数不应抛出异常**：析构函数抛出异常会带来问题，因为在程序退出或异常传播时，如果析构函数抛出异常，可能会导致双重异常，进而引发程序崩溃。因此，析构函数应该捕获任何可能的异常，避免异常向上传播。

---

### 25. **虚函数的执行顺序？父类的析构函数是否要设为虚函数？**
   - **虚函数的执行顺序**：在运行时，虚函数通过虚函数表（vtable）进行动态绑定。当通过基类指针调用虚函数时，会根据指针实际指向的对象类型调用相应的虚函数。
   - **父类的析构函数要设为虚函数**：当通过基类指针删除派生类对象时，必须确保派生类的析构函数也被正确调用，否则会导致派生类资源泄露。因此，如果类是多态的，父类的析构函数必须设为虚函数。

---

### 26. **构造函数和析构函数的执行顺序？析构函数执行顺序为啥相反？**
   - **构造函数执行顺序**：构造函数的调用顺序是从基类到派生类，先调用基类的构造函数，再依次调用派生类的构造函数，最后初始化成员变量。
   - **析构函数执行顺序相反**：析构函数的调用顺序与构造函数相反，首先调用派生类的析构函数，然后依次调用基类的析构函数。这是因为派生类可能依赖基类中的资源，必须确保先销毁派生类的资源，再销毁基类的资源。

---

### 27. **虚析构函数的作用？父类的析构函数是否要设置为虚析构函数？**
   - **虚析构函数的作用**：虚析构函数确保当通过基类指针删除派生类对象时，派生类的析构函数会被正确调用，防止资源泄露。
   - **父类的析构函数要设置为虚函数**：是的，当类被设计为基类并且可能被继承时，析构函数应该是虚函数，确保在删除对象时调用派生类的析构函数。

---

### 28. **构造函数和析构函数可以是私有的吗？为什么？**
   - **构造函数可以是私有的**：通过将构造函数设为私有，可以控制对象的创建。例如，通过友元函数或静态成员函数提供对象的创建。这种设计常用于**单例模式**（Singleton Pattern），确保类的实例只有一个。
   - **析构函数可以是私有的**：将析构函数设为私有可以防止对象被外部代码销毁。这通常在类的生命周期由类自身管理时使用，比如在单例模式中，通过友元函数或静态成员函数控制对象的销毁。

---

### 29. **成员指针和成员函数指针的用法？**
   - **成员指针**：指向类的成员变量的指针。由于成员变量属于类的某个实例，因此需要通过对象来使用成员指针：
     ```cpp
     class MyClass {
         public:
             int data;
     };
     MyClass obj;
     int MyClass::*ptr = &MyClass::data; // 定义成员指针
     obj.*ptr = 10; // 通过对象来访问成员
     ```
   - **成员函数指针**：指向类的成员函数的指针。和成员指针一样，成员函数指针也需要通过类的对象调用：
     ```cpp
     class MyClass {
         public:
             void func() { std::cout << "Hello"; }
     };
     void (MyClass::*funcPtr)() = &MyClass::func; // 定义成员函数指针
     (obj.*funcPtr)(); // 通过对象调用成员函数
     ```

---

### 30. **拷贝构造函数与赋值运算符的区别？**
   - **拷贝构造函数**：用于创建新对象并将另一个对象的值拷贝给它。常用于按值传递对象、从函数返回对象或初始化对象时。语法如下：
     ```cpp
     MyClass(const MyClass &other);
     ```
   - **赋值运算符**：用于将一个已经存在的对象的值复制给另一个已经存在的对象。常用于赋值操作。语法如下：
     ```cpp
     MyClass& operator=(const MyClass &other);
     ```
   - **区别**：拷贝构造函数在对象创建时调用，而赋值运算符在两个对象都已经存在时调用。

---

### 31. **对象生命周期？构造函数和析构函数分别在什么时候调用？**
   - **对象生命周期**：对象的生命周期从创建开始，经过使用，直到销毁结束。在生命周期中，构造函数用于初始化对象，而析构函数用于释放对象的资源。
   - **构造函数调用时间**：对象创建时，构造函数自动调用。
   - **析构函数调用时间**：对象生命周期结束时，析构函数自动调用。对于局部对象，当离开作用域时调用析构函数；对于动态分配的对象，当调用 `delete` 时析构函数被调用。

---

### 32. **多继承的优缺点？为什么会有菱形继承问题？**
   - **多继承的优点**：允许一个类继承多个基类，提供了更大的灵活性，可以复用多个类的功能。
   - **多继承的缺点**：多继承会导致复杂性增加，特别是会出现**菱形继承**问题，即如果两个基类都有相同的基类，派生类可能会包含两份基类的副本。
   - **菱形继承问题**：当一个类通过多继承拥有同一基类的多个副本时，可能会导致数据冗余和不一致。C++ 通过使用**虚继承**来解决这个问题，确保共享一个基类实例。

---

### 33. **介绍一下 C++ 里面的多态？**
   - **多态**：C++ 中的多态性有两种类型：
     - **编译时多态**：通过函数重载和运算符重载实现，编译时决定函数的版本。
     - **运行时多态**：通过虚函数和继承实现，依赖于指针或引用。在运行时，根据指针或引用所指向对象的实际类型调用适当的函数版本。虚函数表（vtable）是实现运行时多态的关键。

---

### 34. **用 C 语言实现 C++ 的继承？**
   - C++ 中的继承在 C 语言中可以通过结构体和函数指针模拟实现。以下是一个简单的例子：
     ```c
     typedef struct {
         int base_member;
     } BaseClass;

     typedef struct {
         BaseClass base;
         int derived_member;
     } DerivedClass;

     void base_func(BaseClass *obj) {
         printf("Base class function\n");
     }

     void derived_func(DerivedClass *obj) {
         base_func(&obj->base);
         printf("Derived class function\n");
     }
     ```
---

### 35. **继承机制中对象之间如何转换？指针和引用之间如何转换？**

   - **对象之间的转换**：
     - 在继承关系中，可以通过**向上转型**（Upcasting）和**向下转型**（Downcasting）进行对象类型的转换。
     - **向上转型**（Upcasting）：将派生类对象的指针或引用转换为基类类型。向上转型是隐式的，因为派生类对象可以自动视为其基类对象。
       ```cpp
       Base* base_ptr = new Derived(); // 向上转型
       ```
     - **向下转型**（Downcasting）：将基类对象的指针或引用转换为派生类类型。这是显式的，需要使用 `dynamic_cast` 或 `static_cast`。
       ```cpp
       Derived* derived_ptr = dynamic_cast<Derived*>(base_ptr); // 向下转型
       ```

   - **指针和引用之间的转换**：
     - 指针和引用在对象类型转换中有相似的规则。可以通过**指针**和**引用**进行向上转型和向下转型。
     - 指针的转换使用 `static_cast` 或 `dynamic_cast`，而引用的转换通常也是通过类似方式进行。

---

### 36. **组合与继承优缺点？**

   - **继承**：
     - **优点**：
       - 允许子类继承父类的功能，代码复用性强。
       - 子类可以重写父类的行为（虚函数），实现多态性。
     - **缺点**：
       - 继承可能造成紧耦合，子类过度依赖于基类，基类的修改会影响所有子类。
       - 继承层次过深时，类结构复杂且难以维护。

   - **组合**：
     - **优点**：
       - 组合通过在类中包含其他类的对象来实现功能复用，依赖性更松散。
       - 组合具有更大的灵活性，组合的对象可以独立存在，类之间的关系较为清晰。
     - **缺点**：
       - 在某些情况下，组合可能导致更多的代码编写，尤其是在封装和调用组合成员时。

---

### 37. **左值右值？**

   - **左值**（L-value）和**右值**（R-value）是表达式中的术语。
     - **左值**：是指可以取地址的对象，通常可以出现在赋值语句的左侧。左值代表了在内存中的某个位置。
       ```cpp
       int a = 10; // a 是左值
       ```
     - **右值**：是不能取地址的临时值，通常只能出现在赋值语句的右侧。右值在表达式结束后不会被保存。
       ```cpp
       int b = a + 5; // a+5 是右值
       ```

   - 在 C++ 中，右值引用（`T&&`）可以绑定到临时对象（右值），通过右值引用，我们可以实现**移动语义**和**完美转发**，从而提高性能。

---

### 38. **移动构造函数？**

   - **移动构造函数**用于将资源从一个对象移动到另一个对象，而不是复制资源。移动构造函数使用右值引用参数（`T&&`）来接收临时对象，并将其内部资源“搬走”而不是复制。
   - 使用移动构造函数的好处是可以避免不必要的深拷贝操作，提升性能。
     ```cpp
     class MyClass {
         int* data;
     public:
         MyClass(MyClass&& other) noexcept : data(other.data) {
             other.data = nullptr; // 释放 old 对象的资源
         }
     };
     ```

---

### 39. **C 活动的移动构造和移动赋值？**

   - 移动构造和移动赋值操作符可以用于类的动态分配资源。通过右值引用，移动构造和赋值运算符允许将资源从一个对象“移动”到另一个对象，避免不必要的内存分配和拷贝。
     - **移动构造函数**：当一个对象通过右值构造时，移动构造函数被调用，将资源“搬走”。
     - **移动赋值运算符**：用于赋值右值给现有对象。左值对象会获得右值对象的资源，而右值对象则被重置为无效状态。

   ```cpp
   class MyClass {
       int* data;
   public:
       // 移动赋值运算符
       MyClass& operator=(MyClass&& other) noexcept {
           if (this != &other) {
               delete[] data;         // 释放旧资源
               data = other.data;     // 盗取资源
               other.data = nullptr;  // 让 other 成为无效对象
           }
           return *this;
       }
   };
   ```

---
### 40. C语言的编译链接过程
1. **预处理 (Preprocessing)**: 处理以 `#` 开头的指令，比如 `#include` 和 `#define`。生成一个扩展的源代码文件。
2. **编译 (Compilation)**: 将预处理后的源代码文件转换为汇编代码。
3. **汇编 (Assembling)**: 汇编代码转化为机器代码，生成目标文件（.obj 或 .o 文件）。
4. **链接 (Linking)**: 将目标文件与库文件结合，生成最终的可执行文件。如果有多文件项目，还会处理符号的解析和地址分配。

### 41. `vector` 与 `list` 的区别与应用？怎么找某 `vector` 或者 `list` 的倒数第二个元素？
- **区别**:
  - `vector`: 基于动态数组实现，支持快速随机访问。适合频繁访问元素但不经常插入或删除的场景。
  - `list`: 基于双向链表实现，支持快速插入和删除操作，但不支持随机访问。

- **找倒数第二个元素**:
  - 对于 `vector`: `vector<T> v; T second_last = v[v.size() - 2];`
  - 对于 `list`: 使用迭代器进行操作，如 `auto it = std::prev(my_list.end(), 2); T second_last = *it;`

### 42. STL `vector` 的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？
- **实现**: `vector` 是一个动态数组，内部使用连续内存块存储元素。
- **删除元素**: 删除元素后，所有位于删除位置后面的元素都会向前移动。这可能使得原有的迭代器失效。
- **两倍扩容**: 扩容策略通常是两倍扩容，以减少频繁的重新分配带来的性能开销。
- **释放空间**: 通过 `shrink_to_fit()` 可以请求释放多余的内存，但这只是一个建议，实际行为依赖于实现。

### 43. 容器内部删除一个元素
删除一个元素后，容器中的元素会根据容器的特性进行重新排列。例如，`vector` 需要移动元素，`list` 只需要调整链接关系。

### 44. STL 迭代器如何实现
STL 迭代器的实现方式取决于容器的类型。一般来说，迭代器是一个类，提供了指向容器元素的操作，包括解引用（`*`）、成员访问（`->`）、前进（`++`）等。每种容器实现自己的迭代器类型，以支持其特性（如随机访问、双向访问等）。

### 45. `set` 与 `hash_set` 的区别
- **`set`**: 实现基于红黑树，元素有序，支持对数时间复杂度的插入、查找和删除。
- **`hash_set`**: 实现基于哈希表，元素无序，插入、查找和删除操作的平均时间复杂度为常数时间（O(1)），但在最坏情况下可能退化为线性时间（O(n)）。

### 46. `hashmap` 与 `map` 的区别
- **`map`**: 基于红黑树实现，元素有序，支持对数时间复杂度的插入、查找和删除。
- **`hashmap`**: 基于哈希表实现，元素无序，插入、查找和删除操作的平均时间复杂度为常数时间（O(1)），但在最坏情况下可能退化为线性时间（O(n)）。

### 47. `map`、`set` 是怎么实现的，红黑树是怎么能够同时实现这两种容器？为什么使用红黑树？
- **实现**: `map` 和 `set` 都是基于红黑树实现的。红黑树是一种自平衡的二叉搜索树，能够保证插入、删除和查找操作的对数时间复杂度。
- **红黑树的特性**: 通过对树进行自我调整，红黑树能够在最坏情况下保持平衡，确保操作的时间复杂度为O(log n)。

### 48. 如何在共享内存上使用 STL 标准库？
STL 容器通常不直接支持在共享内存中使用。可以通过自定义分配器（Allocator）来支持共享内存。需要注意内存管理和同步问题。

### 49. `map` 插入方式有几种？
- **使用 `insert()`**: 可以插入一个 `std::pair` 或者单个元素。
- **使用 `emplace()`**: 直接在 `map` 内部构造元素，避免了不必要的复制或移动操作。
- **使用 `operator[]`**: 如果键不存在，会插入一个默认构造的值。

### 50. STL `unordered_map`（`hash_map`）和 `map` 的区别，`hash_map` 如何解决冲突以及扩容？
- **区别**:
  - `unordered_map` 基于哈希表实现，元素无序，支持平均常数时间复杂度的插入、查找和删除。
  - `map` 基于红黑树实现，元素有序，支持对数时间复杂度的插入、查找和删除。
- **解决冲突**: `unordered_map` 使用链地址法或开放定址法来解决哈希冲突。
- **扩容**: 当负载因子超过阈值时，`unordered_map` 会重新哈希表的大小，并将元素重新分配到新的桶中。

### 51. `vector` 越界访问下标，`map` 越界访问下标？`vector` 删除元素时会不会释放空间？
- **`vector` 越界访问**: 访问未定义的行为，会导致程序崩溃或数据损坏。
- **`map` 越界访问**: `map` 不支持越界访问下标，可以使用 `find()` 方法检查键是否存在。
- **`vector` 删除元素**: 删除元素不会自动释放内存，可以使用 `shrink_to_fit()` 进行空间释放的请求。

### 52. `map` 与 `find` 的区别？
- **`map`**: 是一个关联容器，存储键值对并自动排序。
- **`find`**: 是 `map` 或其他容器的成员函数，用于查找特定元素或键，返回一个迭代器。

以下是对你提出的面试题的回答：

### 53. STL 中 `list` 与 `queue` 之间的区别
- **`list`**: 基于双向链表实现，支持在任意位置快速插入和删除元素，但不支持随机访问。
- **`queue`**: 基于 `deque` 或 `list` 实现的容器适配器，遵循先进先出（FIFO）原则。只能在队列的两端进行操作（`push` 和 `pop`），不支持随机访问。

### 54. STL 中的 `allocator` 和 `deallocator`
- **`allocator`**: 是一个模板类，用于抽象化内存分配的机制。STL 容器通过 `allocator` 进行内存分配和管理。它提供了 `allocate`、`deallocate`、`construct` 和 `destroy` 方法来管理内存。
- **`deallocator`**: 通常指的是 `allocator` 提供的 `deallocate` 方法，用于释放之前分配的内存。

### 55. STL `unordered_map` 扩容发生什么？
- **扩容过程**:
  1. **重新分配**: 分配一个更大的哈希表。
  2. **重新哈希**: 根据新的哈希表大小，将原有元素重新分配到新的桶中。
  3. **更新负载因子**: 计算新的负载因子，并更新哈希表的大小。
- 扩容有助于减少哈希冲突，提高查找效率。

### 56. `map` 如何创建？
- **创建 `map`**: 可以通过以下方式创建一个 `map`:
  ```cpp
  #include <map>

  std::map<int, std::string> my_map; // 创建一个空的 map，键类型为 int，值类型为 std::string
  ```

- **初始化 `map`**:
  ```cpp
  std::map<int, std::string> my_map = {{1, "one"}, {2, "two"}, {3, "three"}};
  ```

### 57. `vector` 的增加和删除都是怎么做的？为什么是1.5倍？
- **增加元素**:
  - **`push_back`**: 在 `vector` 的末尾添加元素。如果容量不足，则需要扩容。
  - **扩容**: 一般情况下，`vector` 扩容时会将容量增加到原容量的 1.5 倍或 2 倍，这样可以平衡内存使用和性能。1.5 倍的策略有助于减少重新分配的次数。

- **删除元素**:
  - **`pop_back`**: 删除末尾的元素，不会影响其他元素。
  - **`erase`**: 删除指定位置的元素，可能需要移动其他元素来填补空缺。

### 58. 函数指针
- **定义**: 函数指针是指向函数的指针，允许通过指针调用函数。
  ```cpp
  void myFunction(int x) {
      // do something
  }

  void (*funcPtr)(int) = myFunction;
  funcPtr(5); // 调用 myFunction(5)
  ```

### 59. 说说你对 C++ 的看法，和 C++ 的区别？
- **C++ 的看法**:
  - C++ 是一门强大的语言，提供了面向对象编程、泛型编程、以及对低级内存操作的控制。
  - 它允许编写高效的系统级代码，但也因为其复杂性和多样性而容易出错。
  - C++ 标准库（STL）为常见数据结构和算法提供了很好的支持。

- **与 C 的区别**:
  - **面向对象**: C++ 支持面向对象编程（OOP），包括类、继承和多态，而 C 是过程式编程语言。
  - **模板**: C++ 支持模板编程，允许在编译时生成代码，提高了代码的重用性和效率。
  - **标准库**: C++ 提供了更丰富的标准库，包括 STL（如 `vector`、`map` 等），而 C 标准库相对较少。

### 60. C/C++ 的内存分配，详细说一下栈、堆、静态存储区
- **栈 (Stack)**:
  - 存储局部变量和函数调用信息。
  - 自动管理内存，函数调用结束后自动释放。
  - 内存分配和释放速度快，但空间有限。

- **堆 (Heap)**:
  - 用于动态分配内存（通过 `new`、`malloc` 等）。
  - 内存管理由程序员负责，需要显式释放内存。
  - 适用于不确定大小的内存需求，但分配和释放速度较慢。

- **静态存储区 (Static Storage)**:
  - 存储静态变量和全局变量。
  - 程序开始时分配，程序结束时释放。
  - 所有对象在整个程序生命周期内存在。

### 61. 堆与栈的区别
- **栈**:
  - 自动管理内存，内存分配和释放速度快。
  - 存储局部变量和函数调用，内存空间有限。
  - 内存分配遵循先进后出（LIFO）规则。

- **堆**:
  - 需要程序员手动管理内存，内存分配和释放速度较慢。
  - 存储动态分配的内存，空间较大。
  - 内存分配没有固定顺序，适用于动态内存需求。

### 62. 野指针是什么？如何检测内存泄漏？
- **野指针**:
  - 野指针是指向已经释放或未初始化的内存位置的指针。使用这样的指针会导致未定义行为。
  
- **检测内存泄漏**:
  - 使用工具如 Valgrind、AddressSanitizer 或其他内存分析工具来检测内存泄漏。

### 63. 悬空指针和野指针有什么区别？
- **悬空指针**:
  - 指向已释放内存的指针，但内存仍未被覆盖或重新分配。使用这种指针可能会导致错误。
  
- **野指针**:
  - 更广泛的概念，指向未初始化或不再有效的内存位置的指针，可能是悬空指针的情况。

### 64. 内存泄漏
- **内存泄漏**:
  - 指程序分配了内存但没有释放，导致无法使用的内存占用系统资源。
  - 可能导致程序运行缓慢或崩溃。
  - 可以通过代码审查、工具（如 Valgrind）和良好的内存管理实践来避免和检测。

### 65. `new` 和 `malloc` 的区别

- **`new`**:
  - 用于分配对象的内存，并调用其构造函数。
  - 会在分配内存时初始化对象。
  - 会在释放内存时调用析构函数。
  - 抛出 `std::bad_alloc` 异常，如果内存分配失败。

- **`malloc`**:
  - 用于分配原始的内存块，不调用构造函数。
  - 不会初始化内存，也不会调用析构函数。
  - 需要手动进行类型转换。
  - 返回 `NULL` 如果内存分配失败。

### 66. `delete p` 与 `delete[] p`，`allocator`

- **`delete p`**:
  - 用于释放通过 `new` 分配的单个对象的内存，并调用对象的析构函数。

- **`delete[] p`**:
  - 用于释放通过 `new[]` 分配的对象数组的内存，并调用每个对象的析构函数。

- **`allocator`**:
  - C++ 标准库中的内存分配器，负责分配和释放内存。`delete` 和 `delete[]` 是基于 `allocator` 进行的操作。

### 67. `new` 和 `delete` 的实现原理，`delete` 是如何知道释放内存的大小的？

- **实现原理**:
  - `new` 操作符通常会调用系统的内存分配函数（如 `malloc`）来分配内存，然后会在分配的内存块前面保存对象的元数据。
  - `delete` 会使用与 `new` 相同的机制来查找内存块的大小和释放它。C++ 标准定义了 `new` 和 `delete` 的对称性，通常 `delete` 依赖于内存分配器来管理对象的大小。

### 68. `malloc` 申请的存储空间能用 `delete` 释放吗？

- **不可以**:
  - `malloc` 申请的内存必须使用 `free` 释放。使用 `delete` 或 `delete[]` 释放由 `malloc` 分配的内存会导致未定义行为。

### 69. `malloc` 和 `free` 的实现原理

- **`malloc`**:
  - 分配内存时会查询内存池或操作系统提供的内存，通过内部的数据结构（如链表）管理已分配和空闲的内存块。
  - 可以通过 `sbrk` 或 `mmap` 系统调用向操作系统请求更多内存。

- **`free`**:
  - 释放内存时会将内存块标记为可用，并可能合并相邻的空闲块，以避免内存碎片。

### 70. `malloc`、`realloc`、`calloc` 的区别

- **`malloc`**: 分配指定字节数的内存块，不初始化内存。
  ```c
  void* malloc(size_t size);
  ```

- **`realloc`**: 调整先前分配的内存块的大小，可能会移动内存块到新的位置。
  ```c
  void* realloc(void* ptr, size_t new_size);
  ```

- **`calloc`**: 分配指定数量的内存块，每个块的大小为指定字节数，并将所有字节初始化为零。
  ```c
  void* calloc(size_t num, size_t size);
  ```

### 71. `stdcall` 和 `_cdecl` 的区别

- **`stdcall`**:
  - 调用约定，由被调用函数清理堆栈。
  - 参数从右到左压入堆栈。
  - 常用于 Windows API 函数。

- **`_cdecl`**:
  - 调用约定，由调用函数清理堆栈。
  - 参数从右到左压入堆栈。
  - 支持可变参数列表。

### 72. 使用智能指针管理内存资源、RAII

- **智能指针**:
  - `std::unique_ptr`：独占拥有的对象，不能拷贝，只能移动。
  - `std::shared_ptr`：多个智能指针共享拥有的对象，使用引用计数管理生命周期。
  - `std::weak_ptr`：辅助 `shared_ptr`，避免循环引用。

- **RAII (Resource Acquisition Is Initialization)**:
  - 资源的管理通过对象的生命周期进行控制，确保在对象销毁时自动释放资源。

### 73. 手写实现智能指针类

这是一个简单的 `unique_ptr` 实现示例：

```cpp
template<typename T>
class unique_ptr {
private:
    T* ptr;

public:
    explicit unique_ptr(T* p = nullptr) : ptr(p) {}
    ~unique_ptr() { delete ptr; }

    // 禁止拷贝构造和拷贝赋值
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

    // 允许移动构造和移动赋值
    unique_ptr(unique_ptr&& other) noexcept : ptr(other.ptr) {
        other.ptr = nullptr;
    }
    unique_ptr& operator=(unique_ptr&& other) noexcept {
        if (this != &other) {
            delete ptr;
            ptr = other.ptr;
            other.ptr = nullptr;
        }
        return *this;
    }

    T* operator->() const { return ptr; }
    T& operator*() const { return *ptr; }
    T* get() const { return ptr; }
};
```

### 74. 内存对齐？位域？

- **内存对齐**:
  - 硬件要求数据按照特定的地址对齐，以提高访问效率。例如，4字节数据应对齐到4字节边界。

- **位域**:
  - 在结构体中定义的特殊成员，用于表示一个结构体中的某些位。例如：
    ```cpp
    struct MyStruct {
        unsigned int a : 3; // 3-bit 位域
        unsigned int b : 5; // 5-bit 位域
    };
    ```

### 75. 结构体变量比较是否相等

- **比较结构体**:
  - 如果结构体的所有成员都可以逐个比较，则可以通过重载 `operator==` 来比较结构体的相等性。

  ```cpp
  struct MyStruct {
      int x;
      int y;

      bool operator==(const MyStruct& other) const {
          return x == other.x && y == other.y;
      }
  };
  ```

### 76. 位运算

- **位运算**:
  - **与运算 (`&`)**: 对应位都为1时结果为1。
  - **或运算 (`|`)**: 对应位有一个为1时结果为1。
  - **异或运算 (`^`)**: 对应位不同结果为1。
  - **取反运算 (`~`)**: 对每一位取反。
  - **左移 (`<<`)**: 将位向左移动。
  - **右移 (`>>`)**: 将位向右移动。

### 77. 为什么内存对齐

- **原因**:
  - **性能**: 许多处理器要求数据按特定的边界对齐以优化访问速度。非对齐访问可能会导致额外的内存访问和性能下降。
  - **硬件限制**: 一些处理器无法进行非对齐的数据访问，必须进行对齐。

### 78. 函数调用过程栈的变化，返回值和参数变量哪个先入栈？

- **函数调用栈变化**:
  1. **入栈**: 函数的参数、返回地址、局部变量等会被推入栈中。
  2. **执行**: 函数体内的操作。
  3. **出栈**: 函数返回时，局部变量、返回地址被弹出栈。

- **参数变量**: 一般情况下，函数参数是先入栈的，然后是返回地址和局部变量等。栈的布局和调用约定有关，可能在不同编译器和平台上有所不同。
### 79. 怎样判断两个浮点数是否相等？

由于浮点数的精度问题，直接比较两个浮点数可能不准确。通常的方法是比较两个浮点数的差是否小于一个预定义的容忍误差（epsilon）值：

```cpp
#include <cmath>

bool areEqual(float a, float b, float epsilon = 1e-6) {
    return std::fabs(a - b) < epsilon;
}
```

这里的 `epsilon` 是一个很小的数值，用来确定两个浮点数是否足够接近。

### 80. 宏定义一个取两个数中较大值

```cpp
#define MAX(a, b) ((a) > (b) ? (a) : (b))
```

宏定义 `MAX` 用于比较两个值并返回较大的一个。

### 81. `define`、`const`、`typedef`、`inline` 使用方法

- **`#define`**:
  - 用于定义宏或常量，简单的文本替换。
  ```cpp
  #define PI 3.14159
  ```

- **`const`**:
  - 用于定义常量，具有类型检查。
  ```cpp
  const int MAX_SIZE = 100;
  ```

- **`typedef`**:
  - 用于为现有类型创建别名。
  ```cpp
  typedef unsigned long ulong;
  ```

- **`inline`**:
  - 提示编译器在调用点插入函数体，通常用于短小的函数以减少函数调用的开销。
  ```cpp
  inline int square(int x) {
      return x * x;
  }
  ```

### 82. `printf` 实现原理

- **`printf`**:
  - **格式解析**: 解析格式字符串中的格式说明符。
  - **参数提取**: 根据格式说明符提取对应的参数。
  - **格式化输出**: 将参数格式化为字符串。
  - **输出**: 将格式化后的字符串输出到标准输出（通常是终端）。

实现过程中涉及到变参函数、格式化处理和系统调用（如 `write`）。

### 83. `#include` 的顺序以及尖括号和双引号

- **`#include` 的顺序**:
  - 包含系统头文件（通常放在开头）。
  - 包含项目内的头文件（通常在系统头文件之后）。

- **尖括号 (`< >`)**:
  - 用于包含标准库头文件或系统头文件，编译器在标准路径中查找文件。

- **双引号 (`" "`)**:
  - 用于包含项目内的头文件，编译器首先在当前目录查找文件，如果找不到才会在标准路径中查找。

### 84. Lambda 函数

- **Lambda 函数**:
  - 是一种匿名函数，可以在需要函数的地方定义并使用。
  - 语法：
  ```cpp
  auto add = [](int a, int b) { return a + b; };
  int result = add(3, 4); // result = 7
  ```

  - 可以捕获外部变量：
  ```cpp
  int x = 10;
  auto add_x = [x](int a) { return a + x; };
  int result = add_x(5); // result = 15
  ```

### 85. "Hello World" 程序开始到打印到屏幕上的全过程

1. **编写代码**: 在源文件中编写 `printf("Hello, World!\n");`。
2. **编译**: 使用编译器将源代码编译成目标文件。
3. **链接**: 将目标文件与标准库链接生成可执行文件。
4. **加载**: 操作系统加载可执行文件到内存。
5. **执行**: 程序执行 `printf` 函数，`printf` 通过系统调用将字符串输出到终端。
6. **显示**: 操作系统显示字符串 "Hello, World!" 到屏幕上。

### 86. 模板类和模板函数的区别是什么？

- **模板函数**:
  - 允许编写可以处理不同类型的函数。
  - 例如：
    ```cpp
    template <typename T>
    T max(T a, T b) {
        return (a > b) ? a : b;
    }
    ```

- **模板类**:
  - 允许编写可以处理不同类型的类。
  - 例如：
    ```cpp
    template <typename T>
    class Stack {
    private:
        std::vector<T> elems;
    public:
        void push(const T& elem) { elems.push_back(elem); }
        T pop() { /* ... */ }
    };
    ```

### 87. 为什么模板类一般都是放在一个 `.h` 文件中？

- **原因**:
  - 模板类在编译时实例化。将模板定义放在头文件中可以让编译器在编译每个使用模板的单元时生成所需的代码。
  - 如果将模板分开到 `.cpp` 文件，编译器在实例化模板时可能找不到模板定义，从而导致链接错误。

### 88. C++ 中类成员的访问权限和继承权限问题

- **访问权限**:
  - **`public`**: 公共成员，任何地方都可以访问。
  - **`protected`**: 保护成员，子类可以访问，但外部不能。
  - **`private`**: 私有成员，只有类内部可以访问。

- **继承权限**:
  - **`public`**: 基类的 `public` 和 `protected` 成员保持其访问权限。
  - **`protected`**: 基类的 `public` 成员变为 `protected`，基类的 `protected` 成员保持 `protected`。
  - **`private`**: 基类的 `public` 和 `protected` 成员都变为 `private`。

### 89. `cout` 和 `printf` 有什么区别？

- **`cout`**:
  - 是 C++ 的输出流，支持类型安全和重载操作符。
  - 使用流插入运算符（`<<`）进行输出。
  - 支持 C++ 的类型系统和对象。

- **`printf`**:
  - 是 C 语言的格式化输出函数。
  - 使用格式说明符（如 `%d`、`%s`）进行输出。
  - 不支持 C++ 的类型系统，更多依赖于 C 风格的格式化字符串。
以下是对你提出的面试题的回答：

### 90. 重载运算符

- **重载运算符**:
  - 允许你为自定义类型定义或修改运算符的行为。
  - 使用 `operator` 关键字定义。例如，重载 `+` 运算符：
    ```cpp
    class Complex {
    public:
        Complex(double r = 0, double i = 0) : real(r), imag(i) {}
        Complex operator+(const Complex& other) const {
            return Complex(real + other.real, imag + other.imag);
        }
    private:
        double real, imag;
    };
    ```
  - 可以重载算术运算符、关系运算符、输入/输出运算符等。

### 91. 函数重载函数匹配

- **函数重载**:
  - 函数重载允许在同一个作用域中定义多个同名的函数，只要它们的参数列表不同（即参数的数量或类型不同）。
  
- **匹配规则**:
  - **精确匹配**: 如果提供的实参类型完全匹配函数参数类型，则选择此函数。
  - **类型提升**: 如果实参可以自动转换为函数参数类型，则选择此函数。
  - **常量转换**: 如果函数参数是 `const` 类型，实参可以转换为 `const` 类型，则选择此函数。

### 92. 定义和声明的区别

- **声明**:
  - 宣布变量、函数或类的存在，告诉编译器它们的名字和类型，但不分配内存或定义实现。
  - 例如：
    ```cpp
    extern int globalVar;  // 声明
    void func();           // 声明
    ```

- **定义**:
  - 分配内存或提供具体实现。
  - 例如：
    ```cpp
    int globalVar = 10;   // 定义
    void func() { /* 实现 */ }  // 定义
    ```

### 93. C++ 类型转换有四种

- **`static_cast`**: 用于普通的类型转换，检查编译时类型安全。
  ```cpp
  int i = 10;
  double d = static_cast<double>(i);
  ```

- **`dynamic_cast`**: 用于在类层次结构中进行安全的运行时类型转换（需要有虚函数）。
  ```cpp
  Base* base = new Derived();
  Derived* derived = dynamic_cast<Derived*>(base);
  ```

- **`const_cast`**: 用于添加或去除对象的 `const` 或 `volatile` 属性。
  ```cpp
  const int i = 10;
  int* ptr = const_cast<int*>(&i);
  ```

- **`reinterpret_cast`**: 用于进行低级别的类型转换，通常用于指针的重新解释。
  ```cpp
  int* ptr = new int(10);
  char* ch = reinterpret_cast<char*>(ptr);
  ```

### 94. 全局变量和 `static` 变量

- **全局变量**:
  - 在所有函数和文件中都可见（在同一翻译单元内）。
  - 定义在文件的外部，生命周期从程序开始到程序结束。

- **`static` 变量**:
  - **函数内部的 `static` 变量**: 在函数调用结束后保持其值，并在下次调用时恢复。
  - **文件内的 `static` 变量**: 只在定义它的文件内可见，其他文件无法访问。

### 95. 静态成员与普通成员的区别

- **静态成员**:
  - 属于类本身，而不是类的任何对象。
  - 所有对象共享同一份静态成员。
  - 可以在类外部定义：
    ```cpp
    class MyClass {
    public:
        static int staticMember;
    };
    
    int MyClass::staticMember = 0; // 定义
    ```

- **普通成员**:
  - 属于类的每个对象，每个对象有自己的副本。
  - 访问普通成员需要通过对象实例。

### 96. 说一下理解 `#ifdef` 和 `#endif`

- **`#ifdef` 和 `#endif`**:
  - 用于条件编译。`#ifdef` 检查宏是否已定义，如果定义了则编译到 `#endif` 之前的代码。
  - 示例：
    ```cpp
    #ifdef DEBUG
    // 调试代码
    #endif
    ```
  - 这用于在编译时决定是否编译某些代码块，通常用于调试或平台特定的代码。

### 97. 隐式转换，如何消除隐式转换？

- **隐式转换**:
  - 编译器在需要时自动将一个类型转换为另一个类型，例如：
    ```cpp
    void func(int x);
    func(3.14); // double 隐式转换为 int
    ```

- **消除隐式转换**:
  - 使用 `explicit` 关键字来防止构造函数的隐式转换：
    ```cpp
    class MyClass {
    public:
        explicit MyClass(int x);
    };
    MyClass obj = 10; // 错误，必须显式调用构造函数
    ```

  - 使用明确的转换函数或构造函数来控制转换行为。

### 98. 虚函数的内存结构，菱形继承的虚函数内存结构

- **虚函数的内存结构**:
  - 每个包含虚函数的类都有一个虚函数表（vtable），虚函数表包含指向虚函数的指针。
  - 每个对象有一个虚指针（vptr），指向对应类的虚函数表。

- **菱形继承的虚函数内存结构**:
  - **菱形继承**: 一个类从两个类继承，这两个类又从一个共同的基类继承。
  - 为避免重复继承基类的虚函数，通常使用虚继承。虚基类有一个虚基表，虚继承的对象通过虚基表来访问共享的基类子对象。
  
  ```cpp
  class A {
  public:
      virtual void func() {}
  };
  
  class B : virtual public A {};
  class C : virtual public A {};
  
  class D : public B, public C {};
  ```
  - 在上面的示例中，`D` 类通过虚继承保证只有一份 `A` 的实例。

### 99. 多继承的优缺点，作为一个开发者怎么看待多继承

- **优点**:
  - **功能复用**: 可以从多个基类中继承功能，避免重复代码。
  - **灵活性**: 允许创建具有多种功能的类。

- **缺点**:
  - **复杂性**: 可能导致复杂的继承结构，增加代码的理解难度。
  - **菱形继承问题**: 如果没有使用虚继承，可能导致重复基类部分。
  - **不明确的继承路径**: 不同基类可能有相同的成员，可能导致二义性。

- **作为开发者的看法**:
  - 在使用多继承时，要仔细设计类的继承结构，尽量避免复杂的继承关系。
  - 使用虚继承来解决菱形继承问题，保持代码的可维护性和清晰度。

以下是对你提出的面试题的回答：

### 100. `迭代器++it` 和 `it++` 哪个更好，为什么？

- **`++it`（前缀递增）**:
  - 直接递增迭代器并返回递增后的迭代器。
  - 通常效率更高，因为不需要创建一个临时迭代器。
  - 适用于所有标准容器的迭代器。

- **`it++`（后缀递增）**:
  - 创建一个临时迭代器，递增原始迭代器，然后返回临时迭代器的值。
  - 可能会有额外的开销，因为涉及到临时对象的创建和销毁。
  - 对于某些容器（如 `std::list`）的迭代器，`it++` 和 `++it` 的性能差异可能不明显。

**结论**: 当性能是关键考虑时，优先使用 `++it`。在大多数情况下，编译器会优化后缀递增，但前缀递增通常更高效。

### 101. C++ 如何处理多个异常

- **异常处理**:
  - 使用 `try` 和 `catch` 块来捕获和处理异常。
  - 可以定义多个 `catch` 块来处理不同类型的异常：
    ```cpp
    try {
        // 可能抛出异常的代码
    } catch (const std::exception& e) {
        // 处理 std::exception 的派生类异常
    } catch (const CustomException& e) {
        // 处理特定类型的自定义异常
    } catch (...) {
        // 处理所有其他异常
    }
    ```

- **异常传播**:
  - 异常会在 `catch` 块中进行捕获，如果当前 `catch` 块无法处理，异常会继续传播到调用者。

### 102. 模板和实现可不可以不写在一个文件里面？为什么？

- **模板实现放在同一个文件**:
  - 模板类和函数的实现通常放在头文件中，因为模板在编译时需要实例化具体类型。将模板定义和实现放在一个文件中，确保编译器在需要时能够访问到实现部分。

- **原因**:
  - 如果模板定义和实现分开，编译器在实例化模板时可能无法找到实现，导致链接错误。

### 103. 在成员函数中调用 `delete this` 会出现什么问题？对象还可以使用吗？

- **`delete this`**:
  - 调用 `delete this` 会销毁当前对象，释放内存。
  - 之后访问该对象会导致未定义行为，可能会导致崩溃或数据损坏。
  - **使用场景**: `delete this` 通常在类的实现中使用，尤其是当对象是动态分配并且负责自身的生命周期时（例如在内存池或自管理对象中）。

- **注意**: 确保对象的生命周期管理非常谨慎，避免在对象销毁后继续使用其指针。

### 104. 智能指针的作用

- **智能指针**:
  - 管理动态分配的对象的生命周期，自动释放内存，避免内存泄漏和悬空指针。
  - **常用类型**:
    - `std::unique_ptr`: 独占所有权，不能拷贝，只能移动。
    - `std::shared_ptr`: 共享所有权，通过引用计数来管理对象的生命周期。
    - `std::weak_ptr`: 与 `std::shared_ptr` 共同使用，用于解决循环引用问题。

### 105. `auto_ptr` 作用

- **`auto_ptr`**:
  - `std::auto_ptr` 是早期 C++ 标准库提供的智能指针，用于自动管理动态分配的内存。
  - 主要提供独占所有权，不能拷贝，只能移动。
  - 已被 `std::unique_ptr` 替代，`std::auto_ptr` 在 C++11 中被弃用。

### 106. `class`、`union`、`struct` 的区别

- **`class`**:
  - 默认访问权限是 `private`。
  - 用于定义具有成员函数和数据成员的复杂类型。
  
- **`struct`**:
  - 默认访问权限是 `public`。
  - 基本功能与 `class` 类似，但更倾向于用于简单的数据聚合。
  
- **`union`**:
  - 允许在同一内存位置存储不同类型的数据，但同一时间只能存储一个类型的数据。
  - 适用于需要节省内存的场景。
  
  ```cpp
  union Data {
      int intVal;
      float floatVal;
  };
  ```

### 107. 动态联编与静态联编

- **静态联编（静态绑定）**:
  - 在编译时决定函数调用的具体实现。
  - 例如，函数重载、运算符重载、模板函数的调用。
  
- **动态联编（动态绑定）**:
  - 在运行时决定函数调用的具体实现，通常涉及虚函数。
  - 通过虚函数表（vtable）实现，允许多态性。
  
  ```cpp
  class Base {
  public:
      virtual void func() { /* ... */ }
  };
  
  class Derived : public Base {
  public:
      void func() override { /* ... */ }
  };
  
  Base* b = new Derived();
  b->func(); // 动态联编
  ```

### 108. 动态编译与静态编译

- **静态编译**:
  - 编译器将所有代码编译到一个可执行文件中，链接时将所有依赖的库代码包含在内。
  - 生成的可执行文件包含所有需要的代码，运行时不需要额外的库文件。
  
- **动态编译**:
  - 通常指动态链接，运行时链接共享库。代码分开在动态链接库（DLL 或 .so 文件）中，减少了可执行文件的大小。

### 109. 动态链接和静态链接区别

- **静态链接**:
  - 编译时将所有需要的库代码编译到可执行文件中。
  - 优点：不需要额外的库文件，启动速度较快。
  - 缺点：生成的可执行文件较大，更新库需要重新编译。

- **动态链接**:
  - 运行时加载共享库文件，库代码不包含在可执行文件中。
  - 优点：减少可执行文件大小，更新库时无需重新编译。
  - 缺点：需要确保共享库在运行时可用，可能导致启动速度较慢。

### 110. 在不使用额外空间的情况下，交换两个数

- **交换两个数**:
  - 使用位运算或加减法来交换两个数而不使用额外空间。

  **使用加减法**:
  ```cpp
  int a = 5;
  int b = 10;
  
  a = a + b;
  b = a - b;
  a = a - b;
  ```

  **使用位运算**:
  ```cpp
  int a = 5;
  int b = 10;
  
  a = a ^ b;
  b = a ^ b;
  a = a ^ b;
  ```

  这两种方法都不需要额外的临时变量来交换两个数的值。

以下是对你提出的面试题的回答：

### 111. `strcpy` 和 `memcpy` 的区别

- **`strcpy`**:
  - 用于复制以 null 结尾的 C 字符串（即 `char` 数组），会拷贝字符串及其终止的 null 字符。
  - 示例：
    ```cpp
    char dest[20];
    const char* src = "Hello";
    strcpy(dest, src);  // dest 现在是 "Hello"
    ```

- **`memcpy`**:
  - 用于复制内存块，适用于任意数据类型，不会处理字符串的终止符。
  - 需要指定源和目标内存区域的大小。
  - 示例：
    ```cpp
    char src[] = "Hello";
    char dest[20];
    memcpy(dest, src, sizeof(src));  // 复制 src 的内容到 dest
    ```

### 112. 执行 `int main(int argc, char *argv[])` 时的内存结构

- **内存结构**:
  - **栈（Stack）**: `argc` 和 `argv` 参数在栈上分配。
    - `argc` 是参数数量。
    - `argv` 是指向字符串的指针数组，每个字符串对应一个命令行参数。
  - **数据段（Data Segment）**: 存储程序中的全局变量和静态变量。
  - **代码段（Code Segment）**: 存储程序的执行代码。
  - **堆（Heap）**: 动态分配的内存区域（通过 `malloc`、`new` 等分配）。

### 113. `volatile` 关键字的作用

- **`volatile`**:
  - 告诉编译器变量的值可能会被异步修改，避免对该变量进行优化。
  - 常用于硬件寄存器的访问和多线程编程中。
  - 示例：
    ```cpp
    volatile int flag;
    ```

### 114. 大端小端，如何检测（三种方法）

- **大端（Big Endian）**:
  - 高字节在低地址，低字节在高地址。
  - 示例：0x12345678 在内存中存储为 `12 34 56 78`。

- **小端（Little Endian）**:
  - 低字节在低地址，高字节在高地址。
  - 示例：0x12345678 在内存中存储为 `78 56 34 12`。

- **检测方法**:
  1. **通过指针和整数**:
     ```cpp
     int num = 1;
     char *ptr = (char*)&num;
     if (*ptr == 1) {
         // 小端
     } else {
         // 大端
     }
     ```
  2. **使用 `union`**:
     ```cpp
     union {
         int i;
         char c[sizeof(int)];
     } u;
     u.i = 1;
     if (u.c[0] == 1) {
         // 小端
     } else {
         // 大端
     }
     ```
  3. **使用标准库函数**（如 `htons` 和 `ntohs`）:
     ```cpp
     #include <arpa/inet.h>
     uint16_t value = 1;
     if (htons(value) == 1) {
         // 小端
     } else {
         // 大端
     }
     ```

### 115. 查看内存的方法

- **查看内存的工具**:
  - **`gdb`**（GNU 调试器）:
    ```bash
    gdb ./my_program
    (gdb) x/10x &variable  // 查看变量地址附近的内存内容
    ```
  - **`hexdump`**:
    ```bash
    hexdump -C myfile
    ```
  - **`valgrind`**（检查内存泄漏和使用）:
    ```bash
    valgrind --leak-check=full ./my_program
    ```

### 116. 空类会默认添加哪些东西？怎么写？

- **空类**:
  - 空类至少有一个成员——一个隐式的虚表指针（vptr），即使没有显式定义任何成员。这是为了支持虚函数和多态。
  - 示例：
    ```cpp
    class Empty {};
    ```

- **大小**:
  - 通常空类的大小为 1 字节（用于区分不同对象）。这个大小是为了确保每个对象有一个唯一的地址。

### 117. 标准库是什么？

- **标准库**:
  - 是 C++ 语言的一部分，提供了多种有用的功能，如容器类、算法、输入/输出、字符串操作等。
  - 包括头文件如 `<vector>`, `<algorithm>`, `<string>`, `<iostream>` 等。

### 118. `const char` 与 `string` 之间的关系，传递参数问题

- **`const char*`**:
  - 指向一个不可修改的 C 风格字符串。
  - 用于表示固定的字符序列。
  
- **`std::string`**:
  - C++ 标准库中的字符串类，提供了丰富的字符串操作功能。
  - 支持动态大小、方便的操作和内存管理。

- **传递参数**:
  - 将 `std::string` 传递给接受 `const char*` 的函数时，使用 `c_str()` 方法：
    ```cpp
    void func(const char* str);
    std::string s = "Hello";
    func(s.c_str());
    ```

- **将 `const char*` 转换为 `std::string`**:
  - 可以直接用 `const char*` 初始化 `std::string`：
    ```cpp
    const char* cstr = "Hello";
    std::string s(cstr);
    ```

### 119. `new`、`delete`、`operator new`、`operator delete`、`placement new`、`placement delete`

- **`new` 和 `delete`**:
  - 用于动态内存分配和释放：
    ```cpp
    int* p = new int; // 分配内存
    delete p;        // 释放内存
    ```

- **`operator new` 和 `operator delete`**:
  - 低级别的内存分配和释放，类似于 `malloc` 和 `free`：
    ```cpp
    void* operator new(size_t size); // 内存分配
    void operator delete(void* ptr); // 内存释放
    ```

- **`placement new` 和 `placement delete`**:
  - 在指定的内存位置构造和析构对象，而不是分配和释放内存：
    ```cpp
    void* buffer = malloc(sizeof(MyClass));
    MyClass* p = new (buffer) MyClass; // 使用 placement new
    p->~MyClass(); // 使用 placement delete
    free(buffer);
    ```

### 120. 为什么拷贝构造函数必须传引用不能传值？

- **拷贝构造函数**:
  - 传递引用而不是值是为了避免在构造过程中复制对象本身（递归调用拷贝构造函数），这会导致无限递归和性能问题。
  - 通过传递 `const` 引用，拷贝构造函数可以避免修改原对象，且只创建一次副本。

  ```cpp
  class MyClass {
  public:
      MyClass(const MyClass& other); // 拷贝构造函数，传递 const 引用
  };
  ```

### 121. 空类的大小是多少？为什么？

- **空类的大小**:
  - 通常为空类分配 1 字节内存。
  - 这是为了确保每个对象有唯一的地址，即使类没有实际的数据成员。这样做可以支持对象的地址和多态性（虚函数表指针）。

这些回答涵盖了你提出的问题。如果还有其他问题或需要进一步解释，请随时告诉我！

```
122. 你什么情况用指针当参数，什么时候用引用，为什么？
123. 大内存申请时候选用哪种？C++变量存在哪？变量的大小存在哪？符号表存在哪？
124. 为什么会有大端小端，htol 这一类函数的作用。
125. 静态函数能定义为虚函数吗？常函数？
126. this 指针调用成员变量时，堆栈会发生什么变化？
127. 静态绑定和动态绑定的介绍。
128. 设计一个类计算子类的个数。
129. 怎么快速定位错误出现的地。
130. 虚函数的代价？
131. 类对象的大小。
132. 移动构造函数。
133. 何时需要合成构造函数。
134. 何时需要合成复制构造函数。
135. 何时需要成员初始化列表？过程是什么？
136. 程序员定义的析构函数被扩展的过程。
137. 构造函数的执行算法？
138. 构造函数的扩展过程？
139. 哪些函数不能是虚函数。
140. sizeof 和 strlen 的区别。
141. 简述 strcpy、sprintf 与 memcpy 的区别。
142. 编码实现某一变量某位清 0 或置 1。
143. 将“引用作为函数参数有哪些特点？
144. 分别写出 BOOL、int、float、指针类型的变量 a 与“零”的比较语句。
145. 局部变量全局变量的问题？
146. 数组和指针的区别？
147. C++如何阻止一个类被实例化？一般在什么时候将构造函数声明为 private？
148. 如何禁止自动生成拷贝构造函数？
149. assert 与 NDEBUG。
150. Debug 和 release 的区别。
151. main 函数有没有返回值。
152. 写一个比较大小的模板函数。
153. c++怎么实现一个函数先于 main 函数运行。
154. 虚函数与纯虚函数的区别在于。
155. 智能指针怎么用？智能指针出现循环引用怎么解决？
156. strcpy 函数和 strncpy 函数的区别？哪个函数更安全。
157. 为什么要用 static_cast 转换而不用 c 语言中的转换。
158. 成员函数里 memset(this,0,sizeof(*this))会发生什么。
159. 方法调用的原理（栈、汇编）。
160. MFC 消息处理如何封装的？
161. 回调函数的作用。
162. 随机数的生成。
```
```
1. 操作系统特点。
2. 什么是进程。
3. 进程。
4. 进程与线程的区别。
5. 进程状态转换图。
6. 进程的创建过程？需要哪些函数？需要哪些数据结构？
7. 进程创建子进程，fork 详解。
8. 子进程和父进程怎么通信？
9. 进程和作业的区别？
10. 死锁是什么？必要条件？如何解决？
11. 鸵鸟策略。
12. 银行家算法。
13. 进程间通信方式有几种，他们之间的区别是什么？
14. 线程同步的方式？怎么用？
15. 页和段的区别？
16. 孤儿进程和僵尸进程的区别？怎么避免这两类进程？
17. 守护进程。守护进程是什么？怎么实现？
18. 线程和进程的区别？线程共享的资源是什么？
19. 线程比进程具有哪些优势？
20. 什么时候用多进程？什么时候用多线程？
21. 协程是什么？
22. 递归锁？
23. 用户态到内核态的转化原理？
24. 中断的实现与作用，中断的实现过程？
25. 系统中断是什么，用户态和内核态的区别 
26. CPU 中断。
27. 执行一个系统调用时：OS 发生的过程，越详细越好。执行用户程序（如：fork）。
28. 函数调用和系统调用的区别？
29. 经典同步问题解法：生产者与消费者问题，哲学家进餐问题，读者写者问题。
30. 虚拟内存？使用虚拟内存的优点？什么是虚拟地址空间？
31. 线程安全？如何实现？
32. linux 文件系。
33. 常见的 IO 模型，五种？异步 IO 应用场景？有什么缺点？IO 复用的原理？零拷贝？三个函数？
34. epoll 的 LT 和 ET 模式的理解。
35. Linux 是如何避免内存碎片的。
36. 递归的原理是啥？递归中遇到栈溢出怎么解决。
37. ++i 是否是原子操作。
38. 缺页中断，页表寻址。
39. LRU 的实现。
40. 内存分区。
41. 伙伴系统相关。
42. I/O 控制方式。
```

```
43. Spooling 技术。
44. 通道技术。
45. 共享内存的实现。
46. 设计一个线程池、内存池。
Linux：
1. Inode 节点。
2. Linux 软连接、硬链接，删除了软连接的源文件软连接可用？
3. Linux 系统应用程序的内存空间是怎么分配的，用户空间多大，内核空间多大？
4. Linux 的共享内存如何实现。
5. 文件处理 grep，awk，sed 这三个命令必知必会。
6. 查询进程占用 CPU 的命令。
7. 一个程序从开始运行到结束的完整过程。
8. 一般情况下在 Linux/windows 平台下栈空间的大小。
9. Linux 重定向。
10. Linux 常用命令。
网络：
物理层。
数据链路层。
网络层。
运输层。
应用层。
数据结构：
1. 常用查找算法？具体实现。
2. 常用排序算法？具体实现，哪些是稳定的，时间复杂度、空间复杂度，快速排序非递归如何实现？快排的优势？
3. 图的常用算法？
4. 哈夫曼编码？
5. AVL 树、B+树、红黑树、B 树区别：B+树应用在哪里。为什么使用红黑树，什么情况使用 AVL 树。红黑树比 AVL 树有什么优点。
6. 
7. 单链表如何判断有环？
8. 如何判断一个图是否连通？
9. hash 用在什么地方，解决 hash 冲突的几种方法？负载因子。
10. n 个节点的二叉树的所有不同构的……
11. 二叉树的公共祖先，排序二叉树的公共祖先。
12. 节点的最大距离。
13. 把一颗二叉树原地变成一个双向链表。
14. 二叉树的所有路径。
15. 二叉树中寻找每一层中最大值。
16. 最大深度、最小深度、会否是平衡树。
17. 二叉树中叶子节点的数量。
18. 交换左右孩子、二叉树镜像。
19. 两个二叉树是否相等。
```
```
20. 是否为完全二叉树。
21. 是否为对称二叉树。
22. 判断 B 是否为 A 的子树。
23. 构建哈夫曼树。
24. 手写单链表反转？删除指定的单链表的一。
25. 实现一个循环队列。
26. Top K 问题。
27. 求一颗树的最大距离。
28. KMP。
29. 数组和链表的区别？
30. 逆序对思路。
31. 100 个有序数组合并。
32. 使用递归和非递归求二叉树的深度。
33. 索引、链表的优缺点？
34. 找点为中心的里包含的所有的点。
35. 字典树的理解。
36. 快速排序的优化。
37. 海量数据的 bitmap 使用原理。算法。
数据库：
1. 事务是什么。
2. 分布式事务。
3. 一二三范式。
4. 数据库的索引类型，数据库索引的作用。
5. 聚集索引和非聚集索引的区别。
6. 唯一性索引和主码索引的区别。
7. 数据库引擎，innodb 和 myisam 的特点与区别。
8. 关系型和非关系型数据库的区别。
9. 数据库的隔离级别。
10. 数据库连接池的作用。
11. 数据的锁的种类，加锁的方式。
12. 数据库 union join 的区别。
13. Inner join、left outter join、right outer join 之间的区别。
设计模式：
1. 单例模式。
2. 手写线程安全的单例模式？
3. 工厂模式。
4. 装饰器模式。
5. 订阅/发布模式。
6. 观察者模式。
7. MVC 模式。
多线程编程。
HR 问题。
```




